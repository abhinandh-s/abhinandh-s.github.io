<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abhi's Feed</title>
  <link href="https://abhinandh-s.github.io/"/>
  <link href="https://abhinandh-s.github.io/atom.xml" rel="self"/>
  <updated>2024-12-10T00:00:00Z</updated>
  <id>https://abhinandh-s.github.io/</id>
  
  <entry>
    <title>age.nvim</title>
    <link href="https://abhinandh-s.github.io/articles/age-nvim"/>
    <id>https://abhinandh-s.github.io/articles/age-nvim</id>
    <updated>2024-12-10T00:00:00Z</updated>
    <summary>Neovim plugin for encrypting and decrypting text files inside neovim using `age` with ease.</summary>
    <content type="html"><![CDATA[**Neovim plugin for encrypting and decrypting text files inside neovim using
`age` with ease.**

# Table of Contents

- [Installation](#installation)
- [Usage](#usage)
- [What is age?](#what-is-age)

# Installation

Install Age using your favorite plugin manager. For example, with
[lazy.nvim](https://github.com/folke/lazy.nvim):

```lua
-- ~/.config/nvim/lua/plugins/age.lua

{
    'abhi-xyz/age.nvim',
    cmd = { "Age" },
    config = function()
      local key = require('key')

      require('age').setup({
        encrypt_and_del = true, -- will remove the original file after encrypting.
        public_key = "ageXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
        private_key = key.private_key, -- defined in another lua file which is not included in git for safety
      })
    end
}
```

```lua
-- ~/.config/nvim/lua/key.lua

return {
  private_key = "AGE-SECRET-KEY-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
}
```

# Usage

Age provides the `:Age` command with the following syntax:

```vim
:Age [action]
```

- `[action]` can be one of:
  - `encrypt`,
  - `decrypt`,
  - `genkey`

## Examples:

- Generates an age key pair into key.txt in current working directory.

```vim
:Age genkey
```

- Kills the current buffer and switches to a previous buffer or creates a
  scratch buffer in case there is no buffer to switch, then encrypts the file
  with the provided age key.

```vim
:Age encrypt
```

- Decrypts the currently opened encrypted file, and switches to the decrypted
  file.

```vim
:Age decrypt
```

## What is age?

[age](https://age-encryption.org/) is a simple, modern and secure file
encryption tool.

It features small explicit keys, no config options, and UNIX-style
composability.

## Why Choose Age Over GPG?

1. **Simplicity**: Age has a straightforward syntax and intuitive design, making
   it easier to use without extensive documentation.
2. **Modern Cryptography**: Age uses state-of-the-art cryptographic algorithms
   like X25519, ChaCha20-Poly1305, and HMAC-SHA256, ensuring robust security.
3. **Minimal Attack Surface**: Age's codebase is minimal and easier to audit
   compared to the complex and extensive GPG ecosystem.
4. **Portable Keys**: Age uses compact, user-friendly key formats, which are
   easy to manage and transfer.
5. **Focused Use Case**: Age is purpose-built for encrypting files securely and
   efficiently, without the additional complexity of key management and email
   encryption that GPG supports.]]></content>
  </entry>

  <entry>
    <title>roxide</title>
    <link href="https://abhinandh-s.github.io/articles/roxide"/>
    <id>https://abhinandh-s.github.io/articles/roxide</id>
    <updated>2024-11-25T00:00:00Z</updated>
    <summary>A lightweight, high-performance alternative to the traditional rm command, written in rust.</summary>
    <content type="html"><![CDATA[`roxide` is a lightweight, high-performance alternative to the traditional `rm`
command, designed with an emphasis on speed and data preservation. Unlike
standard rm, which permanently deletes files, roxide safely moves them to a
designated "`trash`" directory. This approach enables efficient and fast file
removal without risking unintended data loss.

**Note**: I am an amateur Rust programmer, so while this code might not be the
most refined, it prioritizes safety and has been thoroughly tested. If you have
ideas for improvement or notice any issues, contributions are very welcome! This
project is open to suggestions, code reviews, and pull requests from developers
of all experience levels.

## Getting started

- `roxide file.txt`: files will moved to `trash dir`. ie,
  $HOME/.local/share/Trash/files/
- `roxide revert` : restores perviously removed file/directory to its pervious
  path
- `roxide -r | --recursive` : Remove directories and their contents recursively
- `roxide -f | --force` : Remove without moving to trash directory
- `roxide -v | --verbose` : will print the file name and its out path
- `roxide some/dir/ -p .pdf`: will remove files matching the pattern from
  some/dir
- `roxide some/dir/ -rp .pdf`: will recursively remove files matching the
  pattern from some/dir
- `roxide some/dir/ -rp .pdf -l`: will list files, like dry run
- `roxide some/* -i never`: will never prompt
- `roxide some/* -i once`: Prompt once before removing more than three files or
  when removing recursivly
- `roxide some/* -i always`: Prompt before every removal
- `roxide some/* -p .pdf -i always`: Prompt before every removal

> [!WARNING]
>
> 1. Do not use sudo. Support for sudo is still work in progress.
> 2. It wont warn about write protected contents (wip)
> 3. It is not possible to bring back files removed using patterns with `revert`
>    flag but you can still access it from Trash dir

## Installation

### Build

```bash
git clone https://github.com/abhi-xyz/roxide.git --depth=1 
cd roxide
cargo build --release
cp target/release/roxide /usr/local/bin/
```

### cargo

```bash
cargo install roxide
```

### Nixos

Add `roxide` as a flake input: In your flake.nix file, add the roxide input
pointing to its GitHub repository.

```nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    roxide = {
      url = "github:abhi-xyz/roxide";
      inputs.nixpkgs.follows = "nixpkgs"; # Follows the nixpkgs input
    };
  };

  outputs = { self, roxide, nixpkgs, ... }@inputs:
  {
    # Your NixOS configuration or other settings
  };
}
```

Include roxide in NixOS configuration: In the outputs section, set up
nixosConfigurations and add roxide as a module to enable it within your system
configuration.

```nix
{
  outputs = { self, roxide, nixpkgs, ... }@inputs:
  {
    nixosConfigurations."my-nixos-host" = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      specialArgs = { inherit inputs; };
      modules = [
        ./hosts/configuration.nix # Main NixOS configuration file
        roxide.nixosModules.roxide      # Enable the "roxide" module from the flake
      ];
    };
  };
}
```

Activate "roxide" in configuration.nix: Within configuration.nix, enable the
"roxide" program:

```nix
{
  # Other configurations...
  
  program.roxide.enable = true; # note: its program not programs
}
```

Apply Configuration: After updating your configuration, apply it with:

```bash
sudo nixos-rebuild switch --flake .
```

## known bugs

- won't warn about git directory
- can't use sudo
- ~~golb pattern isn't working~~
- ~~pattern -flag interfering with other flags~~
- ~~cant remove a directory which is inside a directory~~

## Planned Features

- ~~roxide revert: Restores files from the trash directory to their original
  location.~~
- roxide --gc <TIME_PERIOD>: Performs garbage collection on trashed files,
  automatically clearing files older than a specified period.
- ~~roxide -f: Forces deletion without moving files to the trash directory.~~
- roxide -s: Shreds files for secure deletion.]]></content>
  </entry>

  <entry>
    <title>Nix Functions To Setup Newsboat Urls</title>
    <link href="https://abhinandh-s.github.io/articles/setting-up-newsboat-the-nix-way"/>
    <id>https://abhinandh-s.github.io/articles/setting-up-newsboat-the-nix-way</id>
    <updated>2024-10-22T00:00:00Z</updated>
    <summary>Setting up your newsboat configuration using Nix functions.</summary>
    <content type="html"><![CDATA[RSS is a powerful way to stay updated with your favorite blogs, social media
channels, and other online content without being distracted by endless scrolling
on the actual platforms. [Newsboat](https://newsboat.org/), a terminal-based RSS
reader, is an excellent tool for this.

In this post, I'll guide you through how to set up your newsboat configuration
using Nix functions to generate RSS feeds from platforms like YouTube, Twitter,
Reddit, Instagram, and Spotify with less boilerplates. For more informations on
supported platforms visit [rsshub](https://rsshub.netlify.app/).

# Setting Up Nix Functions for RSS Feeds

# Nix Functions

In Nix, functions are written as follows:

#### Single parameter

```nix
param1: {
    # Function Body
}
```

#### Two parameters

```nix
param1: param2: {
    # Function Body
}
```

Here, param1, param2, and so on are the inputs (arguments) to the function. This
allows you to write reusable functions where you only need to provide specific
data, such as a username or unique ID, and the function handles the boilerplate
parts of the links.

You might notice that functions in Nix donâ€™t have a name. Nix functions are
similar to closures in Rust, This means you canâ€™t call them directly by name,
they are anonymous. To use them, you must bind the function to a variable. Once
bound, you can call the variable like a named function.

Hereâ€™s an example:

### without funtions

```nix
{ ... }:
let
in
{
    programs.newsboat = {
        enable = true;
        urls = [
            {tags = [ "articles" ]; url = "https://proton.me/blog/feed";}
            { # normal way 
                tags = [ "youtube" "music" ];
                url = "https://rsshub.app/youtube/user/@JFlaMusic";
            }
            { 
                tags = [ "youtube" "movies" ];
                url = "https://rsshub.app/youtube/user/@DanMurrellMovies";
            }
            { 
                tags = [ "youtube" "programming" ];
                url = "https://rsshub.app/youtube/user/@jonhoo";
            }
            { 
                tags = [ "youtube" "programming" ];
                url = "https://rsshub.app/youtube/user/@ThePrimeagen";
            }
            # and so on...
        ]
    };
}
```

### with funtions

```nix
{ ... }:
let
    Youtube = userName: tags: {
        tags = tags;
        url = "https://rsshub.app/youtube/user/@${userName}";
    };
in
    {
    programs.newsboat = {
        enable = true;
        urls = [
            {tags = [ "articles" ]; url = "https://proton.me/blog/feed";}
            (Youtube "JFlaMusic" [ "youtube" "music" ])
            (Youtube "DanMurrellMovies" [ "youtube" "movies" ])
            (Youtube "jonhoo" [ "youtube" "programming" ])
            (Youtube "ThePrimeagen" [ "youtube" "programming" ])
            # and so on...
        ]
    };
}
```

This approach is much cleaner and simplifies debugging in the future. If the API
for RSS changes, you only need to update a single line in the function
definition, rather than rewriting all the occurrences.

# Final code

```nix
{ ... }:
let
instagramFeeds = users: map ( userNames: {
    tags = [ "instagram" ];
    url = "https://rsshub.app/picuki/profile/${userNames}";
    }) users;
twitterFeeds = users: map ( userNames: {
    tags = [ "twitter" ];
    url = "https://nitter.privacydev.net/${userNames}/rss";
    }) users;
redditFeeds = users: map ( userNames: {
    tags = [ "reddit" ];
    url = "https://www.reddit.com/r/${userNames}.rss";
    }) users;
youTubeFeeds = users: map ( userNames: {
    tags = [ "youtube" ];
    url = "https://rsshub.app/youtube/user/@${userNames}";
    }) users;
Youtube = userName: tags: {
  tags = tags;
  url = "https://rsshub.app/youtube/user/@${userName}";
};
YoutubeId = channel_id: tags: {
  tags = tags;
  url = "https://www.youtube.com/feeds/videos.xml?channel_id=${channel_id}";
};
YtMusicChart = category: countryCode: tags: {
  tags = tags;
  url = "https://rsshub.app/youtube/charts/${category}/${countryCode}/RightNow";
};
Spotify = category: name: id: {
  tags = [ "music" ];
  url = "https://rsshub.app/spotify/${category}/${id}";
};
in 
{
  programs.newsboat = {
    enable = true;
    browser = "linkhandler";
    autoReload = false;
    urls = [
      {tags = [ "articles" ]; url = "https://feeds.feedburner.com/collabfund";}
      (Youtube "CinemaStellar" [ "youtube" "movies" ])
      (Youtube "DanMurrellMovies" [ "youtube" "movies" ])
      (YoutubeId "UC7YOGHUfC1Tb6E4pudI9STA" [])
      (YoutubeId "UCP7WmQ_U4GB3K51Od9QvM0w" [])
      (YtMusicChart "TopSongs" "in" [ "YtMusic" ])
      (Spotify "playlist" "Top Songs - Global" "37i9dQZEVXbNG2KDcFcKOF")
      (Spotify "playlist" "Top Songs - India" "37i9dQZEVXbMWDif5SCBJq")
      (Spotify "artist" "Halsey"            "26VFTg2z8YR0cCuwLzESi2")
      (Spotify "artist" "The Chainsmokers"  "69GGBxA162lTqCwzJG5jLp")
      ]
      ++ youTubeFeeds [
        "jonhoo"
        "LukeSmithxyz"
        "NoBoilerplate"
        ]
        ++ twitterFeeds [
          "jonhoo"
          "MikaPikaZo"
        ]
        ++ redditFeeds [
          "rust"
          "nixos"
          "unixporn"
        ]
        ++ instagramFeeds [
          "kartikaaryan"
        ];

    extraConfig = ''
      bind-key j down
      bind-key k up
      '';
  };
}
```]]></content>
  </entry>

  <entry>
    <title>How to Set Up GoDaddy Domain With GitHub Pages</title>
    <link href="https://abhinandh-s.github.io/articles/how-to-set-up-godaddy-domain-with-github-pages"/>
    <id>https://abhinandh-s.github.io/articles/how-to-set-up-godaddy-domain-with-github-pages</id>
    <updated>2024-10-19T00:00:00Z</updated>
    <summary>How to Set Up GoDaddy Domain With GitHub Pages.</summary>
    <content type="html"><![CDATA[Congrats! Youâ€™ve finally bought yourself a domain, and now you're ready to
connect it to your GitHub Pages website. This guide will walk you through the
steps to set up your GoDaddy domain with GitHub Pages.

# Step 1: Configuring GitHub Pages

First, ensure that your repository name follows the required naming convention
for GitHub Pages ie, your repository name must be your-username.github.io.

mine is: https://github.com/abhi-xyz/abhi-xyz.github.io

Once your repository is ready, navigate to the repositoryâ€™s Settings.

## Enable GitHub Pages

1. Go to the Settings of your repository.
2. Scroll down to the Code and Automation section and select Pages.
3. Under Source, choose the branch that contains your static site. For most
   cases, this will be the main or master branch.
4. For the directory, choose root (ie, the directory which the index.html is
   situated).
5. Save the changes, and GitHub will start serving your site from
   your-username.github.io.

# Step 2: Setting Up DNS Records in GoDaddy

Now that your GitHub Pages site is live, the next step is to point your custom
GoDaddy domain to GitHub Pages.

## Add DNS Records in GoDaddy

1. Log in to your [GoDaddy account](https://www.godaddy.com/).
2. Under **My Products**, find your domain and click DNS to manage its DNS
   settings.
3. Add the following entries in the DNS management settings:

![add these entries in GoDaddy's DNS management settings](/static/articles/how-to-set-up-GoDaddy-domain-with-gitHub-pages/01-godaddy-dns-management.avif)

- Type: A
- Name: @
- Value: 185.199.108.153 (Values might change so refer this
  [instructions](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain)
  and put aprropriate values.)

(Repeat this for all four IPs: 185.199.108.153, 185.199.109.153,
185.199.110.153, 185.199.111.153)

- TTL: 600 seconds (default is fine)

4. Add a CNAME record as well: (optional if you want to set www with
   yourdomain.com. ie, www.yourdomain.com)

- Type: CNAME
- Name: www
- Value: your-username.github.io
- TTL: 600 seconds

Save the changes.

# Step 3: Configuring a Custom Domain in GitHub Pages

Once youâ€™ve set up the DNS records in GoDaddy, go back to your GitHub
repository.

Head to Settings > Pages.

![github-pages](/static/articles/how-to-set-up-GoDaddy-domain-with-gitHub-pages/01-github-pages.avif)

Scroll down to the Custom Domain section.

![github-pages settings](/static/articles/how-to-set-up-GoDaddy-domain-with-gitHub-pages/01-github-pages-settings.avif)

Enter your GoDaddy domain (e.g., yourdomain.com) in the field. GitHub will
automatically create a CNAME file in the root directory of your repository. This
file tells GitHub that your website is linked to this custom domain.

![generated CNAME file in root](/static/articles/how-to-set-up-GoDaddy-domain-with-gitHub-pages/01-docs-folder.avif)

After adding the domain, GitHub Pages will take a few minutes to process the
changes.

# Step 4: Check SSL/TLS and HTTPS

After configuring your custom domain, it's crucial to ensure that your website
is served securely over HTTPS. GitHub Pages offers built-in support for HTTPS
through Let's Encrypt, which is a major advantage over traditional domain
providers like GoDaddy.

1. Go to your repository's Settings.
2. In the GitHub Pages section, look for the option to Enforce HTTPS.
3. Enable the Enforce HTTPS checkbox. This will ensure that visitors are
   automatically redirected to the secure version (HTTPS) of your site.

However, after adding your domain, you may encounter a message saying, "TLS
certificate is being provisioned". This is completely normal and indicates that
GitHub is working with Let's Encrypt to issue your SSL certificate. You may need
to refresh the page after some time if the Enforce HTTPS option is disabled at
first.

![TLS certificate provisioned](/static/articles/how-to-set-up-GoDaddy-domain-with-gitHub-pages/tls_provisioned.avif)

## Why HTTPS Matters

Normally, domains purchased from GoDaddy or other providers are routed through
HTTP by default, which means your site won't be secure. When someone visits your
site, their browser will display a warning indicating that the site is not
secure, which can drive away visitors.

If you were to purchase a SSL certificate from GoDaddy, it could cost you
approximately â‚¹4999 annually. However, by using GitHub Pages, you get a free TLS
certificate through Let's Encrypt, giving you secure, encrypted access to your
website without additional costs. This is one of the key benefits of using
GitHub Pages for hosting!

Once the DNS settings propagate (which may take between 24-48 hours), your
GitHub Pages site will be securely accessible through your custom GoDaddy domain
over HTTPS.

Thatâ€™s it! You've successfully set up your GoDaddy domain with GitHub Pages. ðŸŽ‰
Enjoy your new, secure website!]]></content>
  </entry>

  <entry>
    <title>Hello World</title>
    <link href="https://abhinandh-s.github.io/articles/hello-world"/>
    <id>https://abhinandh-s.github.io/articles/hello-world</id>
    <updated>2024-06-26T00:00:00Z</updated>
    <summary>My first blog entry.</summary>
    <content type="html"><![CDATA[# Hello, World!

published: 2024-11-01

Welcome to my first blog post! This content is written in Markdown and styled
using GitHub Flavored Markdown.

```Rust
main() {
    println!("hello world!");
}
```

## Features

- **Light and Dark Mode** support
- Code highlighting:
  ```ts
  console.log("Hello, TypeScript!");
  ```]]></content>
  </entry>

</feed>
